C51 COMPILER V9.52.0.0   MOTOR                                                             01/11/2018 14:57:27 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MOTOR
OBJECT MODULE PLACED IN .\Output\motor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\motor.c OPTIMIZE(4,SPEED) BROWSE INCDIR(.\Code\Common;.\Code;.\Code
                    -\BSP;.\Code\N76E003_HW) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\motor.lst) TABS(2) OBJECT(.\Output\motor.obj)

line level    source

   1          /***********************************************************************************
   2           Company  :   布塔科技
   3           File Name  : motor.c
   4           Author   : WANG 
   5           Create Data  :   2017-05-12
   6           Last Modified  : 2017-05-12
   7           Description  : 电机驱动函数  
   8           Version  :   1.0
   9          ************************************************************************************/
  10          #include "N76E003.h"
  11          #include "Common.h"
  12          #include "motor.h"
  13          #include "PWM.h"
  14          #include "SFR_Macro.h"
  15          #include "delay.h"
  16          #include "Function_define.h"
  17          /**************************************************
  18          *函数名： SetMotor_L
  19          *功能  ： 控制“左电机”的转速与方向
  20                    左电机 ： PWM1 + PWM4
  21          *参数  ：
  22                pwm：0-255  0->停止   255->最大速度
  23                direction：控制电机的正反转   0->正转   1->反转
  24          *返回  ： 无
  25          ***************************************************/
  26          void SetMotor_L(u8 pwm , u8 direction)
  27          {
  28   1        if(pwm == 0)//
  29   1        {
  30   2          SetPWM(1 , 0);
  31   2          SetPWM(4 , 0);
  32   2        }
  33   1        else
  34   1        {
  35   2          pwm += MOTOR_PWM_DIF;
  36   2          if(direction)//??
  37   2          {
  38   3            SetPWM(1 , 0);
  39   3            SetPWM(4 , pwm);  
  40   3          }
  41   2          else//??
  42   2          {
  43   3            SetPWM(1 , pwm);
  44   3            SetPWM(4 , 0);
  45   3          }
  46   2        }
  47   1      }
  48          
  49          /**************************************************
  50          *函数名： SetMotor_R
  51          *功能  ： 控制“右电机”的转速与方向
  52                    右电机 ： PWM3 + PWM0
  53          *参数  ：
  54                pwm：0-255  0->停止   255->最大速度
C51 COMPILER V9.52.0.0   MOTOR                                                             01/11/2018 14:57:27 PAGE 2   

  55                direction：控制电机的正反转   0->正转   1->反转
  56          *返回  ： 无
  57          ***************************************************/
  58          void SetMotor_R(u8 pwm , u8 direction)
  59          {
  60   1        if(pwm == 0)
  61   1        {
  62   2          SetPWM(3 , 0);
  63   2          SetPWM(0 , 0);    
  64   2        }
  65   1        else
  66   1        {
  67   2          pwm += MOTOR_PWM_DIF;
  68   2          if(direction)//??
  69   2          {
  70   3            SetPWM(3 , pwm);
  71   3            SetPWM(0 , 0);
  72   3          }
  73   2          else//??
  74   2          {
  75   3            SetPWM(3 , 0);
  76   3            SetPWM(0 , pwm);  
  77   3          }
  78   2        }
  79   1      }
  80          
  81          /**************************************************
  82          *函数名： SetMotor_STOP
  83          *功能  ： 电机停止转动（不刹车）
  84          *参数  ： 无
  85          *返回  ： 无
  86          ***************************************************/
  87          void SetMotor_STOP(void)
  88          {
  89   1      //  clr_PWMRUN;
  90   1      
  91   1      //  P12=0;P11=0; P00=0;P01=0;
  92   1        
  93   1        SetPWM(1 , 0);
  94   1        SetPWM(4 , 0);
  95   1        SetPWM(3 , 0);
  96   1        SetPWM(0 , 0);
  97   1      }
  98          
  99          /**************************************************
 100          *函数名： SetMotor_Brake
 101          *功能  ： 刹车
 102          *参数  ： 无
 103          *返回  ： 无
 104          ***************************************************/
 105          void SetMotor_Brake(void)
 106          {
 107   1          SetPWM(1 , 0xff);
 108   1          SetPWM(4 , 0xff);
 109   1          SetPWM(3 , 0xff);
 110   1          SetPWM(0 , 0xff);
 111   1      }
 112          
 113          /*
 114            小车电机状态
 115          */
 116          static u8 Motor_Status;
C51 COMPILER V9.52.0.0   MOTOR                                                             01/11/2018 14:57:27 PAGE 3   

 117          void Set_Motor_Status(enum MOTOR_TYPE type , u8 status )
 118          {
 119   1        switch(type)
 120   1        {
 121   2          case MOTOR_MAIN:
 122   2              if(status)
 123   2                Motor_Status |= MOTOR_STATUS_MAIN;
 124   2              else
 125   2                Motor_Status &= ~MOTOR_STATUS_MAIN;
 126   2            break;
 127   2          case MOTOR_ARM:
 128   2              if(status)
 129   2                Motor_Status |= MOTOR_STATUS_ARM;
 130   2              else
 131   2                Motor_Status &= ~MOTOR_STATUS_ARM;      
 132   2            break;
 133   2        }
 134   1      }
 135          u8 Check_Motor_Status(void)
 136          {
 137   1        return Motor_Status;
 138   1      }
 139          
 140          /*
 141            空闲状态检测（电机停止）
 142          */
 143          u8 Check_Motor_Idle(void)
 144          {
 145   1        if(Check_Motor_Status())
 146   1          return 0;//存在电机运转，忙状态
 147   1        else
 148   1          return 1;//电机停止，空闲状态
 149   1      }
 150          
 151          /* 机械臂 */
 152          static ARM_DIR arm_Dir_Tem;
 153          void SetArm( ARM_DIR dir)
 154          {
 155   1        arm_Dir_Tem = dir;
 156   1        switch(dir)
 157   1        {
 158   2        case ARM_UP:
 159   2          MOTOR_ARM_A = 1;
 160   2          MOTOR_ARM_B = 0;
 161   2          break;
 162   2        case ARM_DOWN:
 163   2          MOTOR_ARM_A = 0;
 164   2          MOTOR_ARM_B = 1;
 165   2          break;
 166   2        case ARM_STOP:
 167   2        default:
 168   2          MOTOR_ARM_A = 0;
 169   2          MOTOR_ARM_B = 0;
 170   2          break;
 171   2        }
 172   1      }
 173          /*
 174            获取机械臂状态
 175          */
 176          ARM_DIR GetArmStatus(void)
 177          {
 178   1        return arm_Dir_Tem;
C51 COMPILER V9.52.0.0   MOTOR                                                             01/11/2018 14:57:27 PAGE 4   

 179   1      }
 180          
 181          
 182          /* 前爪 */
 183          static CLAW_DIR claw_Dir_Tem;
 184          void SetClaw( CLAW_DIR dir )
 185          {
 186   1        claw_Dir_Tem = dir;
 187   1        switch(dir)
 188   1        {
 189   2        case CLAW_RELEASE:
 190   2          MOTOR_CLAW_A = 1;
 191   2          MOTOR_CLAW_B = 0;
 192   2          break;
 193   2        case CLAW_HOLD:
 194   2          MOTOR_CLAW_A = 0;
 195   2          MOTOR_CLAW_B = 1;
 196   2          break;
 197   2        case CLAW_STOP: 
 198   2        default:
 199   2          MOTOR_CLAW_A = 0;
 200   2          MOTOR_CLAW_B = 0;
 201   2          break;
 202   2        } 
 203   1      }
 204          CLAW_DIR GetClawStatus(void)
 205          {
 206   1        return claw_Dir_Tem;
 207   1      }
 208          
 209          
 210          /*
 211            左电机
 212            speed < 0 反转
 213            speed > 0 正转
 214          */
 215          void Control_Motor_L(s16 speed)
 216          {
 217   1        if(speed >= 0)
 218   1        {
 219   2          SetMotor_L(speed,0);
 220   2        }
 221   1        else
 222   1        {
 223   2          SetMotor_L(-speed,1);
 224   2        }
 225   1      }
 226          /*
 227            右电机
 228            speed < 0 反转
 229            speed > 0 正转
 230          */
 231          void Control_Motor_R(s16 speed)
 232          {
 233   1        if(speed >= 0)
 234   1        {
 235   2          SetMotor_R(speed,0);
 236   2        }
 237   1        else
 238   1        {
 239   2          SetMotor_R(-speed,1);
 240   2        }
C51 COMPILER V9.52.0.0   MOTOR                                                             01/11/2018 14:57:27 PAGE 5   

 241   1      }
 242          
 243          
 244          /*
 245            小车前后左右控制
 246            speed : 前后速度控制量
 247            dir   : 转向信号控制量
 248          */
 249          void Control_Motor(u8 speed,u8 dir)
 250          {
 251   1        s16 carSpeed_L=0,carSpeed_R=0;
 252   1        //u8 speed_dif;
 253   1        u8 flag=0;
 254   1        
 255   1          carSpeed_L = speed - 0x80;
 256   1          carSpeed_R = speed - 0x80;
 257   1      
 258   1          if( dir != 0x80 )
 259   1          {
 260   2            if(speed == 0x80)//原地转向
 261   2            {
 262   3              if( dir > 0x80 )//
 263   3              {
 264   4                //carSpeed_L = 0;
 265   4                carSpeed_R = dir - 0x80;
 266   4                carSpeed_L = -carSpeed_R/2;
 267   4              }
 268   3              if( dir < 0x80 )
 269   3              {
 270   4                //carSpeed_R = 0;
 271   4                carSpeed_L = 0x80 - dir;
 272   4                carSpeed_R = -carSpeed_L/2;
 273   4              }
 274   3            }
 275   2            else if(speed > 0x80)//前进过程转向
 276   2            {
 277   3              if( dir > 0x80 )//
 278   3              {
 279   4                carSpeed_L = 0;
 280   4                carSpeed_R = dir - 0x80;
 281   4              }
 282   3              if( dir < 0x80 )
 283   3              {
 284   4                carSpeed_R = 0;
 285   4                carSpeed_L = 0x80 - dir;
 286   4              }       
 287   3            }
 288   2            else if(speed < 0x80)//后退过程转向
 289   2            {
 290   3              if( dir > 0x80 )//
 291   3              {
 292   4                carSpeed_L = 0;
 293   4                carSpeed_R = 0x80 - dir;
 294   4              }
 295   3              if( dir < 0x80 )
 296   3              {
 297   4                carSpeed_R = 0;
 298   4                carSpeed_L = dir - 0x80;
 299   4              }           
 300   3            }
 301   2          } 
 302   1        
C51 COMPILER V9.52.0.0   MOTOR                                                             01/11/2018 14:57:27 PAGE 6   

 303   1      //    //Test 全速跑
 304   1      //    if(carSpeed_L < 0)
 305   1      //      carSpeed_L = -0x80;
 306   1      //    else if(carSpeed_L > 0)
 307   1      //      carSpeed_L = 0x80;
 308   1      //    
 309   1      //    if(carSpeed_R < 0)
 310   1      //      carSpeed_R = -0x80;
 311   1      //    else if(carSpeed_R > 0)
 312   1      //      carSpeed_R = 0x80;
 313   1      //    // End Test
 314   1          
 315   1        Control_Motor_L(carSpeed_L);
 316   1        Control_Motor_R(carSpeed_R);
 317   1      }
 318          
 319          /*
 320            接收超时检测
 321            超时则停车
 322          */
 323          //#define TIMEOUT_MOTOR 700
 324          #define TIMEOUT_MOTOR 500
 325          u16 timeOut_Motor=0;
 326          u8 CheckTimeOut_Motor(void)
 327          {
 328   1        if(timeOut_Motor)
 329   1          timeOut_Motor--;
 330   1        else
 331   1          return 1;
 332   1        
 333   1        return 0;
 334   1      }
 335          void Set_TimeOut_Motor(void)
 336          {
 337   1        timeOut_Motor = TIMEOUT_MOTOR;
 338   1      }
 339          
 340          /*
 341            WiFi信号接收超时
 342          */
 343          //#define TIMEOUT_WIFI 1000
 344          #define TIMEOUT_WIFI 800
 345          u16 timeOut_Wifi=0;
 346          u8 CheckTimeOut_Wifi(void)
 347          {
 348   1        if(timeOut_Wifi)
 349   1          timeOut_Wifi--;
 350   1        else
 351   1          return 1;
 352   1        
 353   1        return 0;
 354   1      }
 355          void Set_TimeOut_Wifi(void)
 356          {
 357   1        timeOut_Wifi = TIMEOUT_WIFI;
 358   1      }
 359          
 360          
 361          /*
 362            机械臂控制
 363            参数： arm -> WiFi控制信号
 364          */
C51 COMPILER V9.52.0.0   MOTOR                                                             01/11/2018 14:57:27 PAGE 7   

 365          void Control_ARM(u8 arm)
 366          {
 367   1        if( arm <= 0x40 )
 368   1        {
 369   2          SetArm( ARM_UP );
 370   2          Set_Motor_Status(MOTOR_ARM,1);//设置电机状态
 371   2        }
 372   1        else if( arm >= 0xD0 )
 373   1        {
 374   2          SetArm( ARM_DOWN );
 375   2          Set_Motor_Status(MOTOR_ARM,1);//设置电机状态
 376   2        }
 377   1        else
 378   1        {
 379   2          SetArm( ARM_STOP );
 380   2          Set_Motor_Status(MOTOR_ARM,0);//复位电机状态
 381   2        }
 382   1      
 383   1      }
 384          /*
 385            前爪控制
 386            
 387          */
 388          static u8 claw_Turn_Flag = 0;
 389          static u8 claw_EN = 0;
 390          void Set_Claw_EN(void)
 391          {
 392   1        claw_EN = 1;
 393   1      }
 394          void Reset_Claw_EN(void)
 395          {
 396   1        claw_EN = 0;
 397   1      }
 398          u8 Check_Claw_EN(void)
 399          {
 400   1        return claw_EN;
 401   1      }
 402          void Claw_Trun(void)
 403          {
 404   1        if(claw_Turn_Flag)
 405   1          claw_Turn_Flag = 0;
 406   1        else
 407   1          claw_Turn_Flag = 1;
 408   1      }
 409          void Claw_Dir(void)
 410          {
 411   1        Set_Claw_EN();
 412   1        Set_TimeOut_Claw();
 413   1        if(claw_Turn_Flag)
 414   1          SetClaw( CLAW_HOLD );
 415   1        else
 416   1          SetClaw( CLAW_RELEASE );
 417   1      }
 418          
 419          void Control_Claw(u8 claw)
 420          {
 421   1        
 422   1        if( claw <= 0x40 )
 423   1        {
 424   2          //SetClaw( CLAW_HOLD );
 425   2          Claw_Dir();
 426   2        }
C51 COMPILER V9.52.0.0   MOTOR                                                             01/11/2018 14:57:27 PAGE 8   

 427   1        else if( claw >= 0xC0 )
 428   1        {
 429   2          //SetClaw( CLAW_RELEASE );
 430   2          Claw_Dir();
 431   2        }
 432   1        else
 433   1        {
 434   2          SetClaw( CLAW_STOP );   
 435   2        }
 436   1      }
 437          /*
 438            前爪 信号接收超时
 439          */
 440          //#define TIMEOUT_CLAW 600
 441          #define TIMEOUT_CLAW 400
 442          u16 timeOut_Claw=0;
 443          u8 CheckTimeOut_Claw(void)
 444          {
 445   1        if(timeOut_Claw)
 446   1          timeOut_Claw--;
 447   1        else
 448   1          return 1;
 449   1        
 450   1        return 0;
 451   1      }
 452          void Set_TimeOut_Claw(void)
 453          {
 454   1        timeOut_Claw = TIMEOUT_CLAW;
 455   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    871    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      9       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
