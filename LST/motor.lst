C51 COMPILER V9.52.0.0   MOTOR                                                             11/15/2017 14:35:28 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MOTOR
OBJECT MODULE PLACED IN .\Output\motor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\motor.c OPTIMIZE(4,SPEED) BROWSE INCDIR(.\Code\Common;.\Code;.\Code
                    -\BSP;.\Code\N76E003_HW) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\motor.lst) TABS(2) OBJECT(.\Output\motor.obj)

line level    source

   1          /***********************************************************************************
   2           Company  :   布塔科技
   3           File Name  : motor.c
   4           Author   : WANG 
   5           Create Data  :   2017-05-12
   6           Last Modified  : 2017-05-12
   7           Description  : 电机驱动函数  
   8           Version  :   1.0
   9          ************************************************************************************/
  10          #include "N76E003.h"
  11          #include "Common.h"
  12          #include "motor.h"
  13          #include "PWM.h"
  14          #include "SFR_Macro.h"
  15          #include "delay.h"
  16          
  17          /**************************************************
  18          *函数名： SetMotor_L
  19          *功能  ： 控制“左电机”的转速与方向
  20                    左电机 ： PWM1 + PWM4
  21          *参数  ：
  22                pwm：0-255  0->停止   255->最大速度
  23                direction：控制电机的正反转   0->正转   1->反转
  24          *返回  ： 无
  25          ***************************************************/
  26          void SetMotor_L(u8 pwm , u8 direction)
  27          {
  28   1        if(pwm == 0)//
  29   1        {
  30   2          SetPWM(1 , 0);
  31   2          SetPWM(4 , 0);
  32   2        }
  33   1        else
  34   1        {
  35   2          pwm += MOTOR_PWM_DIF;
  36   2          if(direction)//??
  37   2          {
  38   3            SetPWM(1 , 0);
  39   3            SetPWM(4 , pwm);  
  40   3          }
  41   2          else//??
  42   2          {
  43   3            SetPWM(1 , pwm);
  44   3            SetPWM(4 , 0);
  45   3          }
  46   2        }
  47   1      }
  48          
  49          /**************************************************
  50          *函数名： SetMotor_R
  51          *功能  ： 控制“右电机”的转速与方向
  52                    右电机 ： PWM3 + PWM0
  53          *参数  ：
  54                pwm：0-255  0->停止   255->最大速度
C51 COMPILER V9.52.0.0   MOTOR                                                             11/15/2017 14:35:28 PAGE 2   

  55                direction：控制电机的正反转   0->正转   1->反转
  56          *返回  ： 无
  57          ***************************************************/
  58          void SetMotor_R(u8 pwm , u8 direction)
  59          {
  60   1        if(pwm == 0)
  61   1        {
  62   2          SetPWM(3 , 0);
  63   2          SetPWM(0 , 0);    
  64   2        }
  65   1        else
  66   1        {
  67   2          pwm += MOTOR_PWM_DIF;
  68   2          if(direction)//??
  69   2          {
  70   3            SetPWM(3 , pwm);
  71   3            SetPWM(0 , 0);
  72   3          }
  73   2          else//??
  74   2          {
  75   3            SetPWM(3 , 0);
  76   3            SetPWM(0 , pwm);
  77   3          }
  78   2        }
  79   1      }
  80          
  81          /**************************************************
  82          *函数名： SetMotor_STOP
  83          *功能  ： 电机停止转动（不刹车）
  84          *参数  ： 无
  85          *返回  ： 无
  86          ***************************************************/
  87          void SetMotor_STOP(void)
  88          {
  89   1      //  clr_PWMRUN;
  90   1      
  91   1      //  P12=0;P11=0; P00=0;P01=0;
  92   1        
  93   1        SetPWM(1 , 0);
  94   1        SetPWM(4 , 0);
  95   1        SetPWM(3 , 0);
  96   1        SetPWM(0 , 0);
  97   1      }
  98          
  99          /**************************************************
 100          *函数名： SetMotor_Brake
 101          *功能  ： 刹车
 102          *参数  ： 无
 103          *返回  ： 无
 104          ***************************************************/
 105          void SetMotor_Brake(void)
 106          {
 107   1          SetPWM(1 , 0xff);
 108   1          SetPWM(4 , 0xff);
 109   1          SetPWM(3 , 0xff);
 110   1          SetPWM(0 , 0xff);
 111   1      }
 112          
 113          /* 机械臂 */
 114          static ARM_DIR arm_Dir_Tem;
 115          void SetArm( ARM_DIR dir)
 116          {
C51 COMPILER V9.52.0.0   MOTOR                                                             11/15/2017 14:35:28 PAGE 3   

 117   1        arm_Dir_Tem = dir;
 118   1        switch(dir)
 119   1        {
 120   2        case ARM_UP:
 121   2          MOTOR_ARM_A = 1;
 122   2          MOTOR_ARM_B = 0;
 123   2          break;
 124   2        case ARM_DOWN:
 125   2          MOTOR_ARM_A = 0;
 126   2          MOTOR_ARM_B = 1;
 127   2          break;
 128   2        case ARM_STOP:
 129   2        default:
 130   2          MOTOR_ARM_A = 0;
 131   2          MOTOR_ARM_B = 0;
 132   2          break;
 133   2        }
 134   1      }
 135          /*
 136            获取机械臂状态
 137          */
 138          ARM_DIR GetArmStatus(void)
 139          {
 140   1        return arm_Dir_Tem;
 141   1      }
 142          
 143          
 144          /* 前爪 */
 145          static CLAW_DIR claw_Dir_Tem;
 146          void SetClaw( CLAW_DIR dir )
 147          {
 148   1        claw_Dir_Tem = dir;
 149   1        switch(dir)
 150   1        {
 151   2        case CLAW_RELEASE:
 152   2          MOTOR_CLAW_A = 1;
 153   2          MOTOR_CLAW_B = 0;
 154   2          break;
 155   2        case CLAW_HOLD:
 156   2          MOTOR_CLAW_A = 0;
 157   2          MOTOR_CLAW_B = 1;
 158   2          break;
 159   2        case CLAW_STOP: 
 160   2        default:
 161   2          MOTOR_CLAW_A = 0;
 162   2          MOTOR_CLAW_B = 0;
 163   2          break;
 164   2        } 
 165   1      }
 166          CLAW_DIR GetClawStatus(void)
 167          {
 168   1        return claw_Dir_Tem;
 169   1      }
 170          
 171          
 172          /*
 173            左电机
 174            speed < 0 反转
 175            speed > 0 正转
 176          */
 177          void Control_Motor_L(s16 speed)
 178          {
C51 COMPILER V9.52.0.0   MOTOR                                                             11/15/2017 14:35:28 PAGE 4   

 179   1        if(speed >= 0)
 180   1        {
 181   2          SetMotor_L(speed,0);
 182   2        }
 183   1        else
 184   1        {
 185   2          SetMotor_L(-speed,1);
 186   2        }
 187   1      }
 188          /*
 189            右电机
 190            speed < 0 反转
 191            speed > 0 正转
 192          */
 193          void Control_Motor_R(s16 speed)
 194          {
 195   1        if(speed >= 0)
 196   1        {
 197   2          SetMotor_R(speed,0);
 198   2        }
 199   1        else
 200   1        {
 201   2          SetMotor_R(-speed,1);
 202   2        }
 203   1      }
 204          
 205          
 206          /*
 207            小车前后左右控制
 208            speed : 前后速度控制量
 209            dir   : 转向信号控制量
 210          */
 211          void Control_Motor(u8 speed,u8 dir)
 212          {
 213   1        s16 carSpeed_L=0,carSpeed_R=0;
 214   1        //u8 speed_dif;
 215   1        u8 flag=0;
 216   1        
 217   1          carSpeed_L = speed - 0x80;
 218   1          carSpeed_R = speed - 0x80;
 219   1      
 220   1          if( dir != 0x80 )
 221   1          {
 222   2            if(speed == 0x80)//原地转向
 223   2            {
 224   3              if( dir > 0x80 )//
 225   3              {
 226   4                //carSpeed_L = 0;
 227   4                carSpeed_R = dir - 0x80;
 228   4                carSpeed_L = -carSpeed_R/2;
 229   4              }
 230   3              if( dir < 0x80 )
 231   3              {
 232   4                //carSpeed_R = 0;
 233   4                carSpeed_L = 0x80 - dir;
 234   4                carSpeed_R = -carSpeed_L/2;
 235   4              }
 236   3            }
 237   2            else if(speed > 0x80)//前进过程转向
 238   2            {
 239   3              if( dir > 0x80 )//
 240   3              {
C51 COMPILER V9.52.0.0   MOTOR                                                             11/15/2017 14:35:28 PAGE 5   

 241   4                carSpeed_L = 0;
 242   4                carSpeed_R = dir - 0x80;
 243   4              }
 244   3              if( dir < 0x80 )
 245   3              {
 246   4                carSpeed_R = 0;
 247   4                carSpeed_L = 0x80 - dir;
 248   4              }       
 249   3            }
 250   2            else if(speed < 0x80)//后退过程转向
 251   2            {
 252   3              if( dir > 0x80 )//
 253   3              {
 254   4                carSpeed_L = 0;
 255   4                carSpeed_R = 0x80 - dir;
 256   4              }
 257   3              if( dir < 0x80 )
 258   3              {
 259   4                carSpeed_R = 0;
 260   4                carSpeed_L = dir - 0x80;
 261   4              }           
 262   3            }
 263   2          } 
 264   1        
 265   1        Control_Motor_L(carSpeed_L);
 266   1        Control_Motor_R(carSpeed_R);
 267   1      }
 268          
 269          /*
 270            接收超时检测
 271            超时则停车
 272          */
 273          //#define TIMEOUT_MOTOR 700
 274          #define TIMEOUT_MOTOR 300
 275          u16 timeOut_Motor=0;
 276          u8 CheckTimeOut_Motor(void)
 277          {
 278   1        if(timeOut_Motor)
 279   1          timeOut_Motor--;
 280   1        else
 281   1          return 1;
 282   1        
 283   1        return 0;
 284   1      }
 285          void Set_TimeOut_Motor(void)
 286          {
 287   1        timeOut_Motor = TIMEOUT_MOTOR;
 288   1      }
 289          
 290          /*
 291            WiFi信号接收超时
 292          */
 293          //#define TIMEOUT_WIFI 1000
 294          #define TIMEOUT_WIFI 600
 295          u16 timeOut_Wifi=0;
 296          u8 CheckTimeOut_Wifi(void)
 297          {
 298   1        if(timeOut_Wifi)
 299   1          timeOut_Wifi--;
 300   1        else
 301   1          return 1;
 302   1        
C51 COMPILER V9.52.0.0   MOTOR                                                             11/15/2017 14:35:28 PAGE 6   

 303   1        return 0;
 304   1      }
 305          void Set_TimeOut_Wifi(void)
 306          {
 307   1        timeOut_Wifi = TIMEOUT_WIFI;
 308   1      }
 309          
 310          
 311          /*
 312            机械臂控制
 313            参数： arm -> WiFi控制信号
 314          */
 315          void Control_ARM(u8 arm)
 316          {
 317   1        if( arm <= 0x40 )
 318   1        {
 319   2          SetArm( ARM_UP );
 320   2          // Test code
 321   2          //delayms(1000);
 322   2        }
 323   1        else if( arm >= 0xD0 )
 324   1        {
 325   2          SetArm( ARM_DOWN );
 326   2        }
 327   1        else
 328   1        {
 329   2          SetArm( ARM_STOP );
 330   2        }
 331   1      
 332   1      }
 333          /*
 334            前爪控制
 335            
 336          */
 337          static u8 claw_Turn_Flag = 0;
 338          static u8 claw_EN = 0;
 339          void Set_Claw_EN(void)
 340          {
 341   1        claw_EN = 1;
 342   1      }
 343          void Reset_Claw_EN(void)
 344          {
 345   1        claw_EN = 0;
 346   1      }
 347          u8 Check_Claw_EN(void)
 348          {
 349   1        return claw_EN;
 350   1      }
 351          void Claw_Trun(void)
 352          {
 353   1        if(claw_Turn_Flag)
 354   1          claw_Turn_Flag = 0;
 355   1        else
 356   1          claw_Turn_Flag = 1;
 357   1      }
 358          void Claw_Dir(void)
 359          {
 360   1        Set_Claw_EN();
 361   1        Set_TimeOut_Claw();
 362   1        if(claw_Turn_Flag)
 363   1          SetClaw( CLAW_HOLD );
 364   1        else
C51 COMPILER V9.52.0.0   MOTOR                                                             11/15/2017 14:35:28 PAGE 7   

 365   1          SetClaw( CLAW_RELEASE );
 366   1      }
 367          
 368          void Control_Claw(u8 claw)
 369          {
 370   1        
 371   1        if( claw <= 0x40 )
 372   1        {
 373   2          //SetClaw( CLAW_HOLD );
 374   2          Claw_Dir();
 375   2        }
 376   1        else if( claw >= 0xC0 )
 377   1        {
 378   2          //SetClaw( CLAW_RELEASE );
 379   2          Claw_Dir();
 380   2        }
 381   1        else
 382   1        {
 383   2          SetClaw( CLAW_STOP );   
 384   2        }
 385   1      }
 386          /*
 387            前爪 信号接收超时
 388          */
 389          //#define TIMEOUT_CLAW 600
 390          #define TIMEOUT_CLAW 300
 391          u16 timeOut_Claw=0;
 392          u8 CheckTimeOut_Claw(void)
 393          {
 394   1        if(timeOut_Claw)
 395   1          timeOut_Claw--;
 396   1        else
 397   1          return 1;
 398   1        
 399   1        return 0;
 400   1      }
 401          void Set_TimeOut_Claw(void)
 402          {
 403   1        timeOut_Claw = TIMEOUT_CLAW;
 404   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    791    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
