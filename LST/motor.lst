C51 COMPILER V9.52.0.0   MOTOR                                                             11/06/2017 14:33:05 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MOTOR
OBJECT MODULE PLACED IN .\Output\motor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\motor.c OPTIMIZE(4,SPEED) BROWSE INCDIR(.\Code\Common;.\Code;.\Code
                    -\BSP;.\Code\N76E003_HW) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\motor.lst) TABS(2) OBJECT(.\Output\motor.obj)

line level    source

   1          /***********************************************************************************
   2           Company  :   布塔科技
   3           File Name  : motor.c
   4           Author   : WANG 
   5           Create Data  :   2017-05-12
   6           Last Modified  : 2017-05-12
   7           Description  : 电机驱动函数  
   8           Version  :   1.0
   9          ************************************************************************************/
  10          #include "N76E003.h"
  11          #include "Common.h"
  12          #include "motor.h"
  13          #include "PWM.h"
  14          #include "SFR_Macro.h"
  15          /**************************************************
  16          *函数名： SetMotor_L
  17          *功能  ： 控制“左电机”的转速与方向
  18                    左电机 ： PWM1 + PWM4
  19          *参数  ：
  20                pwm：0-255  0->停止   255->最大速度
  21                direction：控制电机的正反转   0->正转   1->反转
  22          *返回  ： 无
  23          ***************************************************/
  24          void SetMotor_L(u8 pwm , u8 direction)
  25          {
  26   1        if(pwm == 0)//刹车
  27   1        {
  28   2          SetPWM(1 , 0xff);
  29   2          SetPWM(4 , 0xff);
  30   2        }
  31   1        else
  32   1        {
  33   2          pwm += MOTOR_PWM_DIF;
  34   2          if(direction)//??
  35   2          {
  36   3            SetPWM(1 , 0);
  37   3            SetPWM(4 , pwm);  
  38   3          }
  39   2          else//??
  40   2          {
  41   3            SetPWM(1 , pwm);
  42   3            SetPWM(4 , 0);
  43   3          }
  44   2        }
  45   1      }
  46          
  47          /**************************************************
  48          *函数名： SetMotor_R
  49          *功能  ： 控制“右电机”的转速与方向
  50                    右电机 ： PWM3 + PWM0
  51          *参数  ：
  52                pwm：0-255  0->停止   255->最大速度
  53                direction：控制电机的正反转   0->正转   1->反转
  54          *返回  ： 无
C51 COMPILER V9.52.0.0   MOTOR                                                             11/06/2017 14:33:05 PAGE 2   

  55          ***************************************************/
  56          void SetMotor_R(u8 pwm , u8 direction)
  57          {
  58   1        if(pwm == 0)//刹车
  59   1        {
  60   2          SetPWM(3 , 0xff);
  61   2          SetPWM(0 , 0xff);   
  62   2        }
  63   1        else
  64   1        {
  65   2          pwm += MOTOR_PWM_DIF;
  66   2          if(direction)//??
  67   2          {
  68   3            SetPWM(3 , pwm);
  69   3            SetPWM(0 , 0);
  70   3          }
  71   2          else//??
  72   2          {
  73   3            SetPWM(3 , 0);
  74   3            SetPWM(0 , pwm);
  75   3          }
  76   2        }
  77   1      }
  78          
  79          /**************************************************
  80          *函数名： SetMotor_STOP
  81          *功能  ： 电机停止转动（不刹车）
  82          *参数  ： 无
  83          *返回  ： 无
  84          ***************************************************/
  85          void SetMotor_STOP(void)
  86          {
  87   1      //  clr_PWMRUN;
  88   1      
  89   1      //  P12=0;P11=0; P00=0;P01=0;
  90   1        
  91   1        SetPWM(1 , 0);
  92   1        SetPWM(4 , 0);
  93   1        SetPWM(3 , 0);
  94   1        SetPWM(0 , 0);
  95   1      }
  96          
  97          /**************************************************
  98          *函数名： SetMotor_Brake
  99          *功能  ： 刹车
 100          *参数  ： 无
 101          *返回  ： 无
 102          ***************************************************/
 103          void SetMotor_Brake(void)
 104          {
 105   1          SetPWM(1 , 0xff);
 106   1          SetPWM(4 , 0xff);
 107   1          SetPWM(3 , 0xff);
 108   1          SetPWM(0 , 0xff);
 109   1      }
 110          
 111          /* 机械臂 */
 112          static ARM_DIR arm_Dir_Tem;
 113          void SetArm( ARM_DIR dir)
 114          {
 115   1        arm_Dir_Tem = dir;
 116   1        switch(dir)
C51 COMPILER V9.52.0.0   MOTOR                                                             11/06/2017 14:33:05 PAGE 3   

 117   1        {
 118   2        case ARM_UP:
 119   2          MOTOR_ARM_A = 1;
 120   2          MOTOR_ARM_B = 0;
 121   2          break;
 122   2        case ARM_DOWN:
 123   2          MOTOR_ARM_A = 0;
 124   2          MOTOR_ARM_B = 1;
 125   2          break;
 126   2        case ARM_STOP:
 127   2        default:
 128   2          MOTOR_ARM_A = 0;
 129   2          MOTOR_ARM_B = 0;
 130   2          break;
 131   2        }
 132   1      }
 133          /*
 134            获取机械臂状态
 135          */
 136          ARM_DIR GetArmStatus(void)
 137          {
 138   1        return arm_Dir_Tem;
 139   1      }
 140          
 141          
 142          /* 前爪 */
 143          static CLAW_DIR claw_Dir_Tem;
 144          void SetClaw( CLAW_DIR dir )
 145          {
 146   1        claw_Dir_Tem = dir;
 147   1        switch(dir)
 148   1        {
 149   2        case CLAW_RELEASE:
 150   2          MOTOR_CLAW_A = 1;
 151   2          MOTOR_CLAW_B = 0;
 152   2          break;
 153   2        case CLAW_HOLD:
 154   2          MOTOR_CLAW_A = 0;
 155   2          MOTOR_CLAW_B = 1;
 156   2          break;
 157   2        case CLAW_STOP: 
 158   2        default:
 159   2          MOTOR_CLAW_A = 0;
 160   2          MOTOR_CLAW_B = 0;
 161   2          break;
 162   2        } 
 163   1      }
 164          CLAW_DIR GetClawStatus(void)
 165          {
 166   1        return claw_Dir_Tem;
 167   1      }
 168          
 169          
 170          /*
 171            左电机
 172            speed < 0 反转
 173            speed > 0 正转
 174          */
 175          void Control_Motor_L(s16 speed)
 176          {
 177   1        if(speed >= 0)
 178   1        {
C51 COMPILER V9.52.0.0   MOTOR                                                             11/06/2017 14:33:05 PAGE 4   

 179   2          SetMotor_L(speed,0);
 180   2        }
 181   1        else
 182   1        {
 183   2          SetMotor_L(-speed,1);
 184   2        }
 185   1      }
 186          /*
 187            右电机
 188            speed < 0 反转
 189            speed > 0 正转
 190          */
 191          void Control_Motor_R(s16 speed)
 192          {
 193   1        if(speed >= 0)
 194   1        {
 195   2          SetMotor_R(speed,0);
 196   2        }
 197   1        else
 198   1        {
 199   2          SetMotor_R(-speed,1);
 200   2        }
 201   1      }
 202          
 203          
 204          /*
 205            小车前后左右控制
 206            speed : 前后速度控制量
 207            dir   : 转向信号控制量
 208          */
 209          void Control_Motor(u8 speed,u8 dir)
 210          {
 211   1        s16 carSpeed_L=0,carSpeed_R=0;
 212   1        //u8 speed_dif;
 213   1        u8 flag=0;
 214   1        
 215   1          carSpeed_L = speed - 0x80;
 216   1          carSpeed_R = speed - 0x80;
 217   1      
 218   1          if( dir != 0x80 )
 219   1          {
 220   2            if( dir > 0x80 )//
 221   2            {
 222   3              //carSpeed_L = 0;
 223   3              carSpeed_R = dir - 0x80;
 224   3              carSpeed_L = -carSpeed_R;
 225   3            }
 226   2            if( dir < 0x80 )
 227   2            {
 228   3              //carSpeed_R = 0;
 229   3              carSpeed_L = 0x80 - dir;
 230   3              carSpeed_R = -carSpeed_L;
 231   3            }
 232   2            
 233   2      //      if( dir > 0x80 )//右转，右电机减速
 234   2      //      {
 235   2      //        speed_dif = dir-0x80;
 236   2      //        if(carSpeed_R>=0)
 237   2      //          carSpeed_R = carSpeed_R-speed_dif;
 238   2      //        else
 239   2      //          carSpeed_R = carSpeed_R+speed_dif;
 240   2      //      }
C51 COMPILER V9.52.0.0   MOTOR                                                             11/06/2017 14:33:05 PAGE 5   

 241   2      //      else//左转，左电机减速
 242   2      //      {
 243   2      //        speed_dif = 0x80 - dir;
 244   2      //        if(carSpeed_L>=0)
 245   2      //          carSpeed_L = carSpeed_L-speed_dif;  
 246   2      //        else
 247   2      //          carSpeed_L = carSpeed_L+speed_dif;
 248   2      //      }
 249   2          } 
 250   1        
 251   1        Control_Motor_L(carSpeed_L);
 252   1        Control_Motor_R(carSpeed_R);
 253   1      }
 254          
 255          /*
 256            接收超时检测
 257            超时则停车
 258          */
 259          #define TIMEOUT_MOTOR 700
 260          u16 timeOut_Motor=0;
 261          u8 CheckTimeOut_Motor(void)
 262          {
 263   1        if(timeOut_Motor)
 264   1          timeOut_Motor--;
 265   1        else
 266   1          return 1;
 267   1        
 268   1        return 0;
 269   1      }
 270          void Set_TimeOut_Motor(void)
 271          {
 272   1        timeOut_Motor = TIMEOUT_MOTOR;
 273   1      }
 274          
 275          /*
 276            WiFi信号接收超时
 277          */
 278          #define TIMEOUT_WIFI 1000
 279          u16 timeOut_Wifi=0;
 280          u8 CheckTimeOut_Wifi(void)
 281          {
 282   1        if(timeOut_Wifi)
 283   1          timeOut_Wifi--;
 284   1        else
 285   1          return 1;
 286   1        
 287   1        return 0;
 288   1      }
 289          void Set_TimeOut_Wifi(void)
 290          {
 291   1        timeOut_Wifi = TIMEOUT_WIFI;
 292   1      }
 293          
 294          
 295          /*
 296            机械臂控制
 297            参数： arm -> WiFi控制信号
 298          */
 299          void Control_ARM(u8 arm)
 300          {
 301   1        if( arm <= 0x40 )
 302   1        {
C51 COMPILER V9.52.0.0   MOTOR                                                             11/06/2017 14:33:05 PAGE 6   

 303   2          SetArm( ARM_UP );
 304   2        }
 305   1        else if( arm >= 0xD0 )
 306   1        {
 307   2          SetArm( ARM_DOWN );
 308   2        }
 309   1        else
 310   1        {
 311   2          SetArm( ARM_STOP );
 312   2        }
 313   1      
 314   1      }
 315          /*
 316            前爪控制
 317            
 318          */
 319          static u8 claw_Turn_Flag = 0;
 320          static u8 claw_EN = 0;
 321          void Set_Claw_EN(void)
 322          {
 323   1        claw_EN = 1;
 324   1      }
 325          void Reset_Claw_EN(void)
 326          {
 327   1        claw_EN = 0;
 328   1      }
 329          u8 Check_Claw_EN(void)
 330          {
 331   1        return claw_EN;
 332   1      }
 333          void Claw_Trun(void)
 334          {
 335   1        if(claw_Turn_Flag)
 336   1          claw_Turn_Flag = 0;
 337   1        else
 338   1          claw_Turn_Flag = 1;
 339   1      }
 340          void Claw_Dir(void)
 341          {
 342   1        Set_Claw_EN();
 343   1        Set_TimeOut_Claw();
 344   1        if(claw_Turn_Flag)
 345   1          SetClaw( CLAW_HOLD );
 346   1        else
 347   1          SetClaw( CLAW_RELEASE );
 348   1      }
 349          
 350          void Control_Claw(u8 claw)
 351          {
 352   1        
 353   1        if( claw <= 0x40 )
 354   1        {
 355   2          //SetClaw( CLAW_HOLD );
 356   2          Claw_Dir();
 357   2        }
 358   1        else if( claw >= 0xC0 )
 359   1        {
 360   2          //SetClaw( CLAW_RELEASE );
 361   2          Claw_Dir();
 362   2        }
 363   1        else
 364   1        {
C51 COMPILER V9.52.0.0   MOTOR                                                             11/06/2017 14:33:05 PAGE 7   

 365   2          SetClaw( CLAW_STOP );   
 366   2        }
 367   1      }
 368          /*
 369            前爪 信号接收超时
 370          */
 371          #define TIMEOUT_CLAW 600
 372          u16 timeOut_Claw=0;
 373          u8 CheckTimeOut_Claw(void)
 374          {
 375   1        if(timeOut_Claw)
 376   1          timeOut_Claw--;
 377   1        else
 378   1          return 1;
 379   1        
 380   1        return 0;
 381   1      }
 382          void Set_TimeOut_Claw(void)
 383          {
 384   1        timeOut_Claw = TIMEOUT_CLAW;
 385   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    643    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
